/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package home.tests.ipaddrcounter;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.BitSet;
import java.util.zip.ZipFile;

/**
 * Application of ip counter
 * 
 * @author olegshtch
 */
public class App {

    /**
     * Leaf of IPs trees means all children are set
     */
    static final Object ALL_NODES = new Object();
    
    /**
     * Temp {@link BitSet} to reduce allocations
     */
    private static BitSet BITSET_POOL = null;
    /**
     * Temp {@link Object[]} to reduce allocations
     */
    private static Object[] ARRAY_POOL = null;

    /**
     * Get new objects array
     * 
     * <p>Creates new object or re-uses object from pool
     * 
     * @return objects array of size 256
     */
    public static Object[] getNewObjects() {
        if (ARRAY_POOL != null) {
            var result = ARRAY_POOL;
            ARRAY_POOL = null;
            Arrays.fill(result, null);
            return result;
        }
        return new Object[256];
    }
    
    /**
     * Get new bit set
     * 
     * <p>Creates new bit set or re-uses bit set from pool
     * 
     * @return bit set of size 256
     */
    public static BitSet getNewBitSet() {
        if (BITSET_POOL != null) {
            var result = BITSET_POOL;
            BITSET_POOL = null;
            result.set(0, 256, false);
            return result;
        }
        return new BitSet(256);
    }
    
    /**
     * Insert IP to tree
     * 
     * <p>Tree is consists from next nodes:
     * <ul>
     * <li>null - no children are set</li>
     * <li>ALL_NODES - all childre are set</li>
     * <li>BitSet(256) - otherwise on the last 4th level</li>
     * <li>Object[256] - otherwise on the 1st-3rd levels</li>
     * </ul>
     * 
     * @param ip IP to insert
     * @param tree previous tree
     * @return new tree, could be same
     */
    public static Object insertIP(byte[] ip, Object tree) {
        // root
        if (tree == ALL_NODES) {
            return tree;
        }
        boolean noFresh = true; // if is's just created then don't check for compression
        Object[] treeArr;
        if (tree instanceof Object[] arr) {
            treeArr = arr;
        } else if (tree == null) {
            treeArr = getNewObjects();
            tree = treeArr;
            noFresh = false;
        } else {
            return tree;
        }

        // level 1
        final int ip0 = ip[0] & 0xff;
        if (treeArr[ip0] == ALL_NODES) {
            return tree;
        }
        boolean noFresh1 = true; // if is's just created then don't check for compression
        Object[] treeArr1;
        if (treeArr[ip0] instanceof Object[] arr) {
            treeArr1 = arr;
        } else if (treeArr[ip0] == null) {
            treeArr1 = getNewObjects();
            treeArr[ip0] = treeArr1;
            noFresh1 = false;
        } else {
            return tree;
        }
        
        // level 2
        final int ip1 = ip[1] & 0xff;
        if (treeArr1[ip1] == ALL_NODES) {
            return tree;
        }
        boolean noFresh2 = true; // if is's just created then don't check for compression
        Object[] treeArr2;
        if (treeArr1[ip1] instanceof Object[] arr) {
            treeArr2 = arr;
        } else if (treeArr1[ip1] == null) {
            treeArr2 = getNewObjects();
            treeArr1[ip1] = treeArr2;
            noFresh2 = false;
        } else {
            return tree;
        }
        
        // leaves
        final int ip2 = ip[2] & 0xff;
        if (treeArr2[ip2] == ALL_NODES) {
            return tree;
        }
        boolean noFresh3 = true; // if is's just created then don't check for compression
        BitSet treeArr3;
        if (treeArr2[ip2] instanceof BitSet arr) {
            treeArr3 = arr;
        } else if (treeArr2[ip2] == null) {
            treeArr3 = getNewBitSet();
            treeArr2[ip2] = treeArr3;
            noFresh3 = false;
        } else {
            return tree;
        }
        final int ip3 = ip[3] & 0xff;
        treeArr3.set(ip3);
        
        // compress
        if (noFresh3 && treeArr3.cardinality() == 256) {
            BITSET_POOL = treeArr3;
            treeArr2[ip2] = ALL_NODES;
        } else {
            return tree;
        }

        if (noFresh2) {
            for (int i = 0; i < 256; i ++) {
                if (treeArr2[i] != ALL_NODES) {
                    return tree;
                }
            }
            ARRAY_POOL = treeArr2;
            treeArr1[ip1] = ALL_NODES;
        } else {
            return tree;
        }
        
        if (noFresh1) {
            for (int i = 0; i < 256; i ++) {
                if (treeArr1[i] != ALL_NODES) {
                    return tree;
                }
            }
            ARRAY_POOL = treeArr1;
            treeArr[ip0] = ALL_NODES;           
        } else {
            return tree;
        }
        
        if (noFresh) {
            for (int i = 0; i < 256; i ++) {
                if (treeArr[i] != ALL_NODES) {
                    return tree;
                }
            }
            tree = ALL_NODES;
        }
        return tree;
    }
    
    /**
     * Read IPs from {@link InputStream}
     * 
     * @param is input stream
     * @return the tree
     * @throws IOException IO error occurred
     */
    public static Object readIPs(InputStream is) throws IOException {
        try (var bis = new BufferedInputStream(is)) {
            int currentByte = 0;
            byte[] bytes = new byte[4];

            int ch;
            Object tree = null;
            while ((ch = bis.read()) != -1) {
                if (ch == (int)'.') {
                    currentByte++;
                } else if (ch == (int)'\n') {
                    //System.out.println("Line: " + (bytes[0] & 0xff) + "." + (bytes[1] & 0xff) + "." + (bytes[2] & 0xff) + "."+ (bytes[3] & 0xff));
                    if (currentByte == 3) {
                        tree = insertIP(bytes, tree);
                    }
                    currentByte = 0;
                    bytes[0] = bytes[1] = bytes[2] = bytes[3] = 0;
                } else if (ch >= (int)'0' && ch <= (int)'9') {
                    bytes[currentByte] = (byte)(bytes[currentByte] * 10 + (ch - (int)'0'));
                }
            }
            if (currentByte == 3) {
                tree = insertIP(bytes, tree);
            }
            return tree;
        }
    }
    
    /**
     * Count IP in the tree
     * 
     * @param tree the tree
     * @param all_nodes_count value of {@link #ALL_NODES}
     * @return count of IPs
     */
    public static long countIPs(Object tree, long all_nodes_count) {
        if (tree == ALL_NODES) {
            return all_nodes_count;
        }
        if (tree == null) {
            return 0L;
        }
        long sum = 0;
        if (tree instanceof Object[] arr) {
            for (int i = 0; i < 256; i++) {
                sum += countIPs(arr[i], all_nodes_count / 256);
            }
        } else if (tree instanceof BitSet set) {
            sum += set.cardinality();
        }
        return sum;
    }
    
    /**
     * Application entry point
     * 
     * @param args application arguments, path to ZIP archive with file with IPs
     * @throws IOException IO error occurred
     */
    public static void main(String[] args) throws IOException {
        try (var zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ)) {
            var entries = zip.entries();
            if (entries.hasMoreElements()) {
                var entry = entries.nextElement();
                Object tree;
                try (var is = zip.getInputStream(entry)) {
                    tree = readIPs(is);
                }
                System.out.println("Count: " + countIPs(tree, 256L*256*256*256));
            }
        }
    }
}
